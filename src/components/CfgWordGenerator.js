// components/CfgWordGenerator.js
// Synchronous, Earley-guided generator (no BFS/DP).
// API kept simple for the app:
//   CfgWordGenerator.generateWord(n) -> string | null
//   CfgWordGenerator.generateStringOfLength(n) -> string | null
//   CfgWordGenerator.setLogger(fn)
//   CfgWordGenerator.getLastLogs()
//
// IMPORTANT: To avoid touching other files, we read the active CFG from
// window.inputHandler.cfg internally if none is provided.

import { EarleyParser } from './earley/EarleyParser.js';

// ---------- tiny logger (optional) ----------
let externalLogger = null;
let lastLogs = [];
function log(...a) {
  const msg = a.map(String).join(' ');
  lastLogs.push(msg);
  if (externalLogger) {
    try { externalLogger(...a); } catch {}
  } else if (typeof window !== 'undefined' && window.DEBUG_LOGS) {
    console.log('[Gen]', ...a);
  }
}
function resetLogs() { lastLogs = []; }

// ---------- helpers ----------
function getActiveCfg(explicitCfg) {
  // Prefer an explicit cfg if provided; otherwise use the app's global
  if (explicitCfg) return explicitCfg;
  if (typeof window !== 'undefined' && window?.inputHandler?.cfg) {
    return window.inputHandler.cfg;
  }
  throw new Error('CfgWordGenerator: no CFG available.');
}

function terminalsOf(cfg) {
  // Επαναχρησιμοποιούμε το API της κλάσης Cfg
  if (typeof cfg.getTerminals === 'function') return cfg.getTerminals();
  // fallback (δεν αναμένεται να χρειαστεί μέσα στην εφαρμογή)
  const t = new Set();
  for (const [lhs, rhss] of Object.entries(cfg?.cfgObj || {})) {
    for (const rhs of rhss) {
      for (const ch of rhs === window.EMPTY_STRING ? '' : rhs) {
        if (!/[A-Zε]/.test(ch)) t.add(ch);
      }
    }
  }
  return Array.from(t);
}

// Επιστρέφει true αν το prefix μπορεί να επεκταθεί (ή να γίνει πλήρως αποδεκτό)
// δηλ. ο Earley δεν «κολλάει» πριν από το μήκος του prefix.
function earleyProgress(cfg, prefix) {
  const parser = new EarleyParser(cfg);
  const res = parser.parse(prefix, { buildForest: false, debug: false });
  return res.furthestIndex >= prefix.length;
}

// Γρήγορος έλεγχος για πλήρη αποδοχή.
function earleyAccepts(cfg, s) {
  const parser = new EarleyParser(cfg);
  const res = parser.parse(s, { buildForest: false, debug: false });
  return !!res.accepted && res.furthestIndex === s.length;
}

// ---------- core generator (sync, backtracking) ----------
function generateOfLengthSync(n, cfg, opts = {}) {
  const MAX_ATTEMPTS = opts.maxAttempts ?? 5000;
  const PER_POS_TRIALS = opts.perPositionTrials ?? 32;
  const random = opts.random ?? Math.random;

  resetLogs();

  if (n === 0) {
    // Η εφαρμογή ζητά μήκος >=1 μέσω UI, αλλά υποστηρίζουμε και n=0 για πληρότητα.
    const ok = earleyAccepts(cfg, '');
    log(ok ? 'ε is generated.' : 'ε is NOT generated.');
    return ok ? '' : null;
  }

  const terms = terminalsOf(cfg);
  if (terms.length === 0) {
    log('No terminal symbols found in CFG.');
    return null;
  }

  // Σταθερό shuffle iterator
  function* shuffled(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    yield* a;
  }

  let attempts = 0;
  const stack = []; // for debugging choices: {pos, choice}

  function dfs(prefix) {
    if (++attempts > MAX_ATTEMPTS) return null;

    if (prefix.length === n) {
      if (earleyAccepts(cfg, prefix)) {
        log(`✅ Found string: "${prefix}"`);
        return prefix;
      }
      log(`reject full "${prefix}"`);
      return null;
    }

    // Δοκίμασε επόμενους τερματικούς με pruning από Earley (στο prefix+ch)
    let triedHere = 0;
    for (const ch of shuffled(terms)) {
      if (++triedHere > PER_POS_TRIALS) break;
      const candidate = prefix + ch;

      // prune: ο Earley πρέπει να «προχωρά» τουλάχιστον μέχρι το νέο μήκος
      if (!earleyProgress(cfg, candidate)) {
        log(`prune "${candidate}"`);
        continue;
      }

      stack.push({ pos: prefix.length, choice: ch });
      const deeper = dfs(candidate);
      if (deeper != null) return deeper;
      stack.pop();
    }

    return null;
  }

  const ans = dfs('');
  if (ans == null) {
    log(`❌ Exhausted attempts (${attempts}) without finding a string of length ${n}.`);
  }
  return ans;
}

// ---------- public API (object export) ----------
export const CfgWordGenerator = {
  /**
   * Generate a string of exact length n generated by the current CFG.
   * Returns: string | null
   *
   * NOTE: No need to pass cfg; the generator reads window.inputHandler.cfg internally
   * to stay compatible with the rest of the app (modal.js, etc.).
   */
  generateWord(n, cfg = null, opts = {}) {
    const activeCfg = getActiveCfg(cfg);
    return generateOfLengthSync(n, activeCfg, opts);
  },

  // Back-compat alias used in some places
  generateStringOfLength(n, cfg = null, opts = {}) {
    return this.generateWord(n, cfg, opts);
  },

  setLogger(fn) {
    externalLogger = typeof fn === 'function' ? fn : null;
  },

  getLastLogs() {
    return [...lastLogs];
  }
};

// default export for default imports
export default CfgWordGenerator;
